using System;
using System.Collections;
using System.Collections.Generic;

#if UNITY_5_3_OR_NEWER
    using UnityEngine;
#endif


namespace DemolitionStudios.DemolitionMedia
{
    /// <summary>
    /// Main class for working with a single media source
    /// </summary>
    public partial class Media : IDisposable
    {
#region fields

        ///  Url of the media: file name or web address
        public string mediaUrl;

        /// Whether to enable audio stream
        public bool enableAudio = false;

        /// Whether to use native audio plugin
        public bool useNativeAudioPlugin = true;

        /// Whether to open the media on component start
        public bool openOnStart = true;

        /// Whether to play the media when it's opened
        public bool playOnOpen = false;

        /// Whether to preload file to the system memory
        public bool preloadToMemory = false;

        /// Events
        private MediaEvent _events = new MediaEvent();
        public MediaEvent Events
        {
            get { return _events; }
        }

        /// Unique media id. Generated by the native plugin code
        private int _mediaId = -1;
        public int MediaId
        {
            get { return _mediaId; }
        }

        /// Duration of the media stream in seconds
        public float DurationSeconds
        {
            //get { return NativePlugin.GetDuration(_mediaId); }
            get; private set;
        }

        /// Current playback position in seconds
        public float CurrentTime
        {
            get { return NativeDll.GetCurrentTime(_mediaId); }
        }

        /// Current state of the media
        public MediaState State
        {
            get { return NativeDll.GetMediaState(_mediaId); }
        }

        /// Whether the media is currently playing
        public bool IsPlaying
        {
            get { return NativeDll.IsPlaying(_mediaId); }
        }

        /// Whether the media is currently has non-zero number of loops remaining
        public bool IsLooping
        {
            get { return NativeDll.IsLooping(_mediaId); }
        }

        /// Whether the media is finished playing
        public bool IsFinished
        {
            get { return NativeDll.IsFinished(_mediaId); }
        }

        /// Active segment for looping
        private int _startFrame = 0;
        public int StartFrame
        {
            get { return _startFrame; }
            set {
                _startFrame = value;
                _startTime = value * VideoFramerate;
                NativeDll.SetActiveSegmentFrames(_mediaId, _startFrame, _endFrame);
                UpdateVideoDecodeFramerateInterval();
            }
        }
        private int _endFrame = 0;
        public int EndFrame
        {
            get { return _endFrame; }
            set
            {
                _endFrame = value;
                _endTime = value * VideoFramerate;
                NativeDll.SetActiveSegmentFrames(_mediaId, _startFrame, _endFrame);
                UpdateVideoDecodeFramerateInterval();
            }
        }
        private float _startTime = 0.0f;
        public float StartTime
        {
            get { return _startTime; }
            set
            {
                _startTime = value;
                _startFrame = (int) (value / VideoFramerate);
                NativeDll.SetActiveSegment(_mediaId, _startTime, _endTime);
                UpdateVideoDecodeFramerateInterval();
            }
        }
        private float _endTime = 0.0f;
        public float EndTime
        {
            get { return _endTime; }
            set
            {
                _endTime = value;
                _endFrame = (int)(value / VideoFramerate);
                NativeDll.SetActiveSegment(_mediaId, _startTime, _endTime);
                UpdateVideoDecodeFramerateInterval();
            }
        }

        private void UpdateVideoDecodeFramerateInterval()
        {
            _videoDecodeFramerateInterval = Math.Min(1.0f, 0.5f * Math.Abs(_endTime - _startTime));
            _videoDecodeFramerateTime = 0.0f;
        }

        /// Framedrop
        public bool FramedropEnabled
        {
            get { return NativeDll.GetFramedropEnabled(_mediaId); }
            set { NativeDll.SetFramedropEnabled(_mediaId, value); }
        }

        /// Framedrop count
        public void GetFramedropCount(out int earlyDrops, out int lateDrops)
        {
            NativeDll.GetFramedropCount(_mediaId, out earlyDrops, out lateDrops);
        }

        /// Number of loops remaining for this media playback.
        /// Negative value means infinite
        public int Loops
        {
            get { return NativeDll.GetLoops(_mediaId); }
            set { NativeDll.SetLoops(_mediaId, value); }
        }

        /// Sync mode
        public SyncMode SyncMode
        {
            //get; set;
            get { return NativeDll.GetSyncMode(_mediaId); }
            set { NativeDll.SetSyncMode(_mediaId, value); }
        }

        /// Playback speed
        public float PlaybackSpeed
        {
            get { return NativeDll.GetPlaybackRate(_mediaId); }
            set
            {
                if (enableAudio && Math.Abs(value - 1.0) > 1e-5)
                {
                    Debug.LogWarning("[DemolitionMedia] If you want to change the playback speed, " +
                                     "it's recommended to disable the audio!");
                }

                NativeDll.SetPlaybackRate(_mediaId, value);
            }
        }

        /// Video stream pixel format
        public PixelFormat VideoPixelFormat { get; private set; }
        //public PixelFormat VideoPixelFormat
        //{
        //    get { return NativeDll.GetPixelFormat(_mediaId); }
        //}

        /// Video stream frame width
        public int VideoWidth { get; private set; }

        /// Video stream frame height
        public int VideoHeight { get; private set; }

        /// Video stream framerate
        public float VideoFramerate { get; private set; }

        /// Video stream frame aspect ratio
        public float VideoAspectRatio
        {
            get { return (float)VideoWidth / VideoHeight; }
        }

        /// Number of frames in the video stream
        public int VideoNumFrames
        {
            //get { return NativePlugin.GetNumFrames(_mediaId); }
            get; private set;
        }

        /// Current frame index in the video stream
        public int VideoCurrentFrame
        {
            get { return NativeDll.GetCurrentFrame(_mediaId); }
        }

        /// Video decode framerate
        private int _videoDecodeFramerateFrameCount = 0;
		private float _videoDecodeFramerateInterval = 1.0f;
        private float _videoDecodeFramerateTime = 0.0f;
		private float _videoDecodeFramerate = 1000.0f;
		public float VideoDecodeFramerate
		{
			get { return Math.Min(_videoDecodeFramerate, VideoFramerate); }
		}

        /// Whether we need to flip the video on the X axis for correct displaying
        public bool VideoNeedFlipX { get; private set; }

        /// Whether we need to flip the video on the Y axis for correct displaying
        public bool VideoNeedFlipY { get; private set; }

        /// Whether the external texture has been set for the material
        private bool _textureSet = false;

        /// Whether currently opening the media
        private bool _opening = false;

        /// Cached media state
        private MediaState _stateCached = MediaState.Closed;

        /// Sets the audio parameters
        public static void SetAudioParams(SampleFormat sampleFormat, int sampleRate, int bufferLength, int channels)
        {
            NativeDll.SetAudioParams(sampleFormat, sampleRate, bufferLength, channels);
        }

        // Fills audio buffer with data (SampleFormat.Float or SampleFormat.Float_Planar)
        public void FillAudioBuffer(float[] buffer, int offset, int length, int channels)
        {
            NativeDll.FillAudioBuffer(_mediaId, buffer, offset, length, channels);
        }
        #endregion


        #region media interface
        public bool Open(string url)
        {
            // Open the media (async)
            // Close the old media if one was opened previously
            Close();

            if (_mediaId < 0)
            {
                _mediaId = NativeDll.CreateNewMediaId();
            }

            // Prevent from crashing on null string value
            if (url == null)
                url = "";

            var openingUrl = PreOpenImpl(url);
            var openingStarted = NativeDll.Open(openingUrl, enableAudio, useNativeAudioPlugin,
                                                preloadToMemory, SyncMode, _mediaId);
            if (!openingStarted)
            {
                _opening = false;
                Debug.LogError("[DemolitionMedia] Failed to start opening media from url: " + openingUrl);
                return false;
            }
            _opening = true;

            // Force the opening state
            //_stateCached = MediaState.Opening;
            InvokeEvent(MediaEvent.Type.OpeningStarted);
            if (preloadToMemory)
            {
                InvokeEvent(MediaEvent.Type.PreloadingToMemoryStarted);
            }

            Debug.Log("[DemolitionMedia] Started opening media from url: " + openingUrl);

            // Update the cached media url
            mediaUrl = url;

            return true;
        }

        public void Close()
        {
            if (_mediaId < 0)
                return;

            InvokeEvent(MediaEvent.Type.ClosingStarted);

            // FIXME: call NativePlugin.Close() first?
            CloseImpl();

            NativeDll.Close(_mediaId);
            mediaUrl = "";

            // Force the closed media state
            _stateCached = MediaState.Closed;

            ResetCachedProperties();
            _videoDecodeFramerateInterval = 1.0f;

            InvokeEvent(MediaEvent.Type.Closed);
        }

        public void Play()
        {
            //// Timecode: reset
            //if (State == MediaState.Stopped)
            //{
            //    if (SyncMode == SyncMode.SyncExternalClockValue)
            //    {
            //        ExternalClockValue = 0.0f;
            //    }
            //}

            _videoDecodeFramerateTime = 0.0f;
            NativeDll.Play(_mediaId);
        }

        public void Pause()
        {
            _videoDecodeFramerateTime = 0.0f;
            NativeDll.Pause(_mediaId);
        }

        public void TogglePause()
        {
            _videoDecodeFramerateTime = 0.0f;
            NativeDll.TogglePause(_mediaId);
        }

        public void StepForward()
        {
            NativeDll.StepForward(_mediaId);
        }

        public void StepBackward()
        {
            NativeDll.StepBackward(_mediaId);
        }

        public void SeekToTime(float seconds)
        {
            NativeDll.SeekToTime(_mediaId, seconds);
        }

        public void SeekToFrame(int frame)
        {
            NativeDll.SeekToFrame(_mediaId, frame);
        }

        public void ToggleMute()
        {
            NativeDll.ToggleMute(_mediaId);
        }
        #endregion

        #region internal

        private void OnOpened()
        {
            Debug.Log("[DemolitionMedia] Opened media with url: " + mediaUrl);

            // Cache the media parameters
            int width, height;
            NativeDll.GetResolution(_mediaId, out width, out height);
            VideoWidth = width;
            VideoHeight = height;

            DurationSeconds = NativeDll.GetDuration(_mediaId);
            VideoNumFrames = NativeDll.GetNumFrames(_mediaId);
            VideoFramerate = NativeDll.GetFramerate(_mediaId);

            bool flipX, flipY;
            NativeDll.GetNeedFlipVideo(_mediaId, out flipX, out flipY);
            VideoNeedFlipX = flipX;
            VideoNeedFlipY = flipY;

            VideoPixelFormat = NativeDll.GetPixelFormat(_mediaId);
            Debug.Log("[DemolitionMedia] video pixel format: " + VideoPixelFormat);

            // Check hardware acceleration ability
            bool hasHardwareAcceleration = NativeDll.IsDecodingHardwareAccelerated(_mediaId);
            Debug.Log("[DemolitionMedia] Hardware acceleration: " + hasHardwareAcceleration);

            // Execute host application-dependent code
            OnOpenedImpl();

            // Start playing if needed
            if (playOnOpen)
                Play();
        }

        private void PopulateErrors()
        {
            MediaError error = NativeDll.GetError(_mediaId);
            if (error != MediaError.NoError)
            {
                if (_opening)
                {
                    ResetCachedProperties();

                    InvokeEvent(MediaEvent.Type.OpenFailed, error);
                    _opening = false;

                    Debug.LogError("[DemolitionMedia] OpenFailed: " + error.ToString());
                }
                else
                {
                    InvokeEvent(MediaEvent.Type.PlaybackErrorOccured, error);

                    Debug.LogError("[DemolitionMedia] PlaybackErrorOccured: " + error.ToString());
                }
            }
        }

        private void PopulateEvents()
        {
            MediaState state = NativeDll.GetMediaState(_mediaId);

            // Nothing has happeded
            if (state == _stateCached)
                return;

            var finished = NativeDll.IsFinished(_mediaId);

            //if (_stateCached == MediaState.Closed && state == MediaState.Opening)
            //    return;
            if ((_stateCached == MediaState.Closed ||
                 _stateCached == MediaState.Opening ||
                 _stateCached == MediaState.PreloadingToMemory) &&
                 state != MediaState.Error &&
                 state != MediaState.Opening &&
                 state != MediaState.PreloadingToMemory)
            {
                //Debug.Log("Cached: " + _stateCached.ToString() + ", new: " + state.ToString());

                // Note: sometimes the state can change directly from PreloadingToMemory to Opened
                if (_stateCached == MediaState.PreloadingToMemory)
                    InvokeEvent(MediaEvent.Type.PreloadingToMemoryFinished);

                OnOpened();
                InvokeEvent(MediaEvent.Type.Opened);

                if (state == MediaState.Playing)
                    InvokeEvent(MediaEvent.Type.PlaybackStarted);
            }
            else if (_stateCached == MediaState.PreloadingToMemory)
            {
                InvokeEvent(MediaEvent.Type.PreloadingToMemoryFinished);
            }
            else if (_stateCached == MediaState.Stopped && state == MediaState.Playing)
            {
                InvokeEvent(MediaEvent.Type.PlaybackStarted);
            }
            else if (_stateCached == MediaState.Playing && state == MediaState.Paused)
            {
                InvokeEvent(MediaEvent.Type.PlaybackSuspended);
            }
            else if (_stateCached == MediaState.Paused && state == MediaState.Playing)
            {
                InvokeEvent(MediaEvent.Type.PlaybackResumed);
            }
            else if (_stateCached == MediaState.Playing && state == MediaState.Stopped &&
                     finished)
            {
                InvokeEvent(MediaEvent.Type.PlaybackEndReached);
            }
            if ((_stateCached == MediaState.Playing ||
                 _stateCached == MediaState.Paused) && state == MediaState.Stopped)
            {
                InvokeEvent(MediaEvent.Type.PlaybackStopped);
            }
            else if (state == MediaState.Closed)
            {
                InvokeEvent(MediaEvent.Type.Closed);
            }

            // Update the cached state
            _stateCached = state;
        }

        void ResetCachedProperties()
        {
            DurationSeconds = 0.0f;
            VideoNumFrames = 0;
            VideoWidth = 0;
            VideoHeight = 0;
            VideoFramerate = 0.0f;
            StartTime = 0.0f;
            EndTime = 0.0f;
            StartFrame = 0;
            EndFrame = 0;
            VideoPixelFormat = PixelFormat.None;
        }
        #endregion

        public void Dispose()
        {
            Close();
        }
    }
}